locals {
  unique_domains = toset(var.domains)

  connections_list = try(jsondecode(terracurl_request.aviatrix_connections.response).results.connections, [])

  defined_domains = keys(aviatrix_segmentation_network_domain.domains)

  length_keyed = [for d in local.defined_domains : "${format("%03d", length(d))}${d}"]
  sorted_keyed = reverse(sort(local.length_keyed))
  sorted_domain_names = [for s in local.sorted_keyed : substr(s, 3, -1)]

  inferred_domains = {
    for conn in local.connections_list :
    conn.name => (
      startswith(lower(conn.name), "external-") ?
      try(
        [
          for domain in local.sorted_domain_names :
          domain
          if strcontains(lower(substr(conn.name, length("external-"), -1)), lower(domain))
        ][0],
        ""
      ) : ""
    )
  }

  filtered_connections = [
    for conn in local.connections_list :
    conn
    if conn.tunnel_type == "Transit_BGP"
    && conn.bgp_status == "enabled"
    && conn.bgp_transit == true
  ]

  domain_attachment_pairs = flatten([
    for conn in local.filtered_connections : [
      for gw in data.aviatrix_transit_gateways.all_transit_gws.gateway_list : [
        {
          key             = "${local.inferred_domains[conn.name]}~${conn.name}"
          network_domain  = local.inferred_domains[conn.name]
          attachment_name = conn.name
          transit_gateway = gw.gw_name
        }
      ]
      if gw.gw_name == split(",", replace(conn.gw_name, " ", ""))[0]
      && (gw.cloud_type == 1 || gw.cloud_type == 4)
    ]
    if local.inferred_domains[conn.name] != "" && contains(local.defined_domains, local.inferred_domains[conn.name])
  ])

  association_map = { for pair in local.domain_attachment_pairs : pair.key => pair }
}

resource "terracurl_request" "aviatrix_connections" {
  name            = "aviatrix_connections"
  url             = "https://${data.aws_ssm_parameter.aviatrix_ip.value}/v2/api"
  method          = "POST"
  skip_tls_verify = true

  request_body = jsonencode({
    action = "list_site2cloud"
    CID    = jsondecode(data.http.controller_login.response_body)["CID"]
  })

  headers = {
    "Content-Type" = "application/json"
  }

  response_codes = [200]
  depends_on     = [data.http.controller_login]

  destroy_url    = var.destroy_url
  destroy_method = "GET"

  lifecycle {
    postcondition {
      condition     = jsondecode(self.response)["return"]
      error_message = "Failed to create access account: ${jsondecode(self.response)["reason"]}"
    }

    ignore_changes = all
  }
}

resource "aviatrix_segmentation_network_domain" "domains" {
  for_each    = local.unique_domains
  domain_name = each.value
}

resource "aviatrix_segmentation_network_domain_connection_policy" "test_segmentation_network_domain_connection_policy" {
  for_each      = { for idx, policy in var.connection_policy : "${policy.source}-${policy.target}" => policy }
  domain_name_1 = each.value.source
  domain_name_2 = each.value.target
  depends_on    = [aviatrix_segmentation_network_domain.domains]
}

resource "aviatrix_segmentation_network_domain_association" "domain_associations" {
  for_each             = local.association_map
  network_domain_name  = each.value.network_domain
  transit_gateway_name = each.value.transit_gateway
  attachment_name      = each.value.attachment_name

  depends_on = [aviatrix_segmentation_network_domain.domains, terracurl_request.aviatrix_connections]
}